import numpy as np
import math


# классификация методом k ближайших соседей
# X - обучающее множество.
#   Строки соответствуют объектам,
#   столбцы - признакам.
#   Последний столбец - номер класса
# k - количество ближайших соседей (не более числа объектов в X)
# obj - объект, который нужно классифицировать
def k_nearest(X, k, obj):
    # TODO: выполнить нормализацию каждого столбца (кроме последнего)
    #       матрицы X, пользуясь формулой с практики по k-means. Для этого удобно
    # сохранить часть матрицы X без последнего столбца в матрицу sub_X

    sub_X = X[:, 0:-1]
    Maxi = np.max(sub_X, axis=0)

    sub_X = sub_X - np.average(sub_X)
    std = np.std(sub_X - np.average(sub_X))
    sub_X = sub_X / std

    #Midle = np.sum(sub_X, axis=0) / len(sub_X)
    #stand_dev = np.sqrt(np.sum((sub_X - Midle) ** 2, axis=0) / len(sub_X))

    # TODO: зная параметры среднего и среднеквадратического отклонения
    #       по каждому столбцу sub_X, выполнить нормализацию объекта obj
    obj = obj / Maxi
    #obj = (obj - Midle) / stand_dev
    # TODO: рассчитать евклидово расстояние от obj до каждого объекта sub_X (функция dist ниже).
    # Реализовать можно с помощью цикла for. Существуют разные варианты записи этого цикла, например, такой:

    distances = [dist(i, obj) for i in sub_X]

    # TODO: Получить с помощью функции np.argsort индексы соседей по мере их удаления от obj.
    # Для справки по функции argsort выполните в консоли Python команду help('numpy.argsort')

    index_of_dist = np.argsort(distances)

    # TODO: выбрать в отдельный вектор классы k ближайших соседей
    # Нужно взять k строк из матрицы X, соответствующих ближайшим соседям.
    # Индексы строк ближайших соседей были получены на предыдущем шаге.
    # Из этих строк нас интересует только последнее значение (последний столбец матрицы X),
    # так как там хранится класс объекта.

    nearest_classes = X[index_of_dist[:k], -1]

    # TODO: определить наиболее часто встречающийся класс в этом векторе. Просто раскомментируйте код ниже:
    unique, counts = np.unique(nearest_classes, return_counts=True)
    object_class = unique[np.argmax(counts)]

    # TODO: вернуть полученное значение из функции. Искомый класс объекта obj хранится в переменной object_class
    return object_class


# вычисление евклидова расстояния между двумя точками
def dist(p1, p2):
    return math.sqrt(sum((p1 - p2) ** 2))
